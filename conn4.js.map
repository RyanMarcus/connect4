{"version":3,"file":"ui/conn4.js","sources":["conn4.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","sourcesContent":["/*\n\nCopyright 2014 Ryan Marcus\n\nThis file is part of Connect4AI.\n\nConnect4AI is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nConnect4AI is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Connect4AI.  If not, see <http://www.gnu.org/licenses/>.\n\n */\n\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#define OFF_BOARD -2\n#define EMPTY -1\n#define LOOK_AHEAD 5\n#define TABLE_SIZE 32000\n#define TABLE_BIN_SIZE 10\n\ntypedef struct {\n\tint width;\n\tint height;\n\tint* board;\n\tint last_move;\n\tint weight;\n\n\tint refs;\n} GameState;\n\nGameState* newGameState(int width, int height) {\n\tGameState* toR = (GameState*) malloc(sizeof(GameState));\n\ttoR->width = width;\n\ttoR->height = height;\n\ttoR->board = (int*) malloc(sizeof(int) * width * height);\n\ttoR->weight = 0;\n\ttoR->refs = 1;\n\n\tfor (int i = 0; i < width * height; i++) {\n\t\ttoR->board[i] = EMPTY;\n\t}\n\n\treturn toR;\n}\n\nvoid freeGameState(GameState* gs) {\n\tgs->refs--;\n\tif (gs->refs <= 0) {\n\t\tfree(gs->board);\n\t\tfree(gs);\n\t}\n}\n\nvoid retainGameState(GameState* gs) {\n\tgs->refs++;\n}\n\nint at(GameState* gs, int x, int y) {\n\tif (x < 0 || y < 0)\n\t\treturn OFF_BOARD;\n\n\tif (x >= gs->width || y >= gs->height)\n\t\treturn OFF_BOARD;\n\n\treturn gs->board[x * gs->height + y];\n}\n\nvoid drop(GameState* gs, int column, int player) {\n\tfor (int i = 0; i < gs->height; i++) {\n\t\tif (at(gs, column, i) == EMPTY) {\n\t\t\tgs->board[column * gs->height + i] = player;\n\t\t\tgs->last_move = column;\n\t\t\treturn;\n\t\t}\n\t}\n\n\n}\n\nint checkAt(GameState* gs, int x, int y) {\n\t// check across\n\tint found = 1;\n\tint curr = at(gs, x, y);\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (at(gs, x + i, y) != curr) {\n\t\t\tfound = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && (curr != EMPTY && curr != OFF_BOARD))\n\t\treturn curr;\n\n\t// check down\n\tfound = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (at(gs, x, y + i) != curr) {\n\t\t\tfound = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && (curr != EMPTY && curr != OFF_BOARD))\n\t\treturn curr;\n\n\t// check diag +/+\n\tfound = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (at(gs, x + i, y + i) != curr) {\n\t\t\tfound = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && (curr != EMPTY && curr != OFF_BOARD))\n\t\treturn curr;\n\n\t// check diag -/+\n\tfound = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (at(gs, x - i, y + i) != curr) {\n\t\t\tfound = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && (curr != EMPTY && curr != OFF_BOARD))\n\t\treturn curr;\n\n\treturn 0;\n}\n\nint getIncrementForArray(int* arr, int player) {\n\tint toR = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (arr[i] == player) {\n\t\t\ttoR = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (arr[i] != player && arr[i] != EMPTY) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn toR;\n}\n\nint countAt(GameState* gs, int x, int y, int player) {\n\n\t// check across\n\tint found = 0;\n\tint buf[4];\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tbuf[i] = at(gs, x + i, y);\n\t}\n    \n\tfound += getIncrementForArray(buf, player);\n\n\t// check down\n\tfor (int i = 0; i < 4; i++) {\n\t\tbuf[i] = at(gs, x, y + i);\n\t}\n\tfound += getIncrementForArray(buf, player);\n\n\t// check diag +/+\n\tfor (int i = 0; i < 4; i++) {\n\t\tbuf[i] = at(gs, x + i, y + i);\n\t}\n\tfound += getIncrementForArray(buf, player);\n\n\t// check diag -/+\n\tfor (int i = 0; i < 4; i++) {\n\t\tbuf[i] = at(gs, x - i, y + i);\n\t}\n\tfound += getIncrementForArray(buf, player);\n\n\treturn found;\n}\n\nint getWinner(GameState* gs) {\n\tfor (int x = 0; x < gs->width; x++) {\n\t\tfor (int y = 0; y < gs->height; y++) {\n\t\t\tint res = checkAt(gs, x, y);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint isDraw(GameState* gs) {\n\tfor (int x = 0; x < gs->width; x++) {\n\t\tfor (int y = 0; y < gs->height; y++) {\n\t\t\tif (at(gs, x, y) == EMPTY)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nint getHeuristic(GameState* gs, int player, int other_player) {\n\tint toR = 0;\n\tfor (int x = 0; x < gs->width; x++) {\n\t\tfor (int y = 0; y < gs->height; y++) {\n\t\t\ttoR += countAt(gs, x, y, player);\n\t\t\ttoR -= countAt(gs, x, y, other_player);\n\t\t}\n\t}\n\t\n\treturn toR;\n}\n\nint canMove(GameState* gs, int column) {\n\tfor (int y = 0; y < gs->height; y++) {\n\t\tif (at(gs, column, y) == EMPTY)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nGameState* stateForMove(GameState* orig, int column, int player) {\n\tGameState* toR = newGameState(orig->width, orig->height);\n\tmemcpy(toR->board, orig->board, sizeof(int) * orig->width * orig->height);\n\tdrop(toR, column, player);\n\treturn toR;\n}\n\nvoid printGameState(GameState* gs) {\n\tfor (int i = 0; i < gs->width; i++) {\n\t\tprintf(\"%d \", i);\n\t}\n\n\tprintf(\"\\n\");\n\t\n\tfor (int y = gs->height - 1; y >= 0 ; y--) {\n\t\tfor (int x = 0; x < gs->width; x++) {\n\t\t\tint toP = at(gs, x, y);\n\t\t\tif (toP == EMPTY) {\n\t\t\t\tprintf(\"  \");\n\t\t\t} else {\n\t\t\t\tprintf(\"%d \", toP);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (int i = 0; i < gs->width; i++) {\n\t\tprintf(\"%d \", i);\n\t}\n\n\tprintf(\"\\n\\n\");\n}\n\nunsigned long hashGameState(GameState* gs) {\n\tunsigned long long hash = 14695981039346656037Lu;\n\tfor (int i = 0; i < gs->width * gs->height; i++) {\n\t\thash ^= gs->board[i];\n\t\thash *= 1099511628211Lu;\n\t}\n\treturn hash;\n}\n\nint isGameStateEqual(GameState* gs1, GameState* gs2) {\n\tif (gs1->width != gs2->width || gs1->height != gs2->height)\n\t\treturn 0;\n\n\tfor (int i = 0; i < gs1->width * gs1->height; i++) {\n\t\tif (gs1->board[i] == gs2->board[i])\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\ntypedef struct {\n\tGameState*** bins;\n} TranspositionTable;\n\n\nTranspositionTable* newTable() {\n\tTranspositionTable* toR = (TranspositionTable*) malloc(sizeof(TranspositionTable));\n\ttoR->bins = (GameState***) malloc(sizeof(GameState**) * TABLE_SIZE);\n\tfor (int i = 0; i < TABLE_SIZE; i++) {\n\t\ttoR->bins[i] = (GameState**) malloc(sizeof(GameState*) * TABLE_BIN_SIZE);\n\t\tfor (int j = 0; j < TABLE_BIN_SIZE; j++) {\n\t\t\ttoR->bins[i][j] = NULL;\n\t\t}\n\t}\n\n\treturn toR;\n}\n\nGameState* lookupInTable(TranspositionTable* t, GameState* k) {\n\tint hv = hashGameState(k) % TABLE_SIZE;\n\tGameState** bin = t->bins[hv];\n\tfor (int i = 0; i < TABLE_BIN_SIZE; i++) {\n\t\tif (bin[i] == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (isGameStateEqual(k, bin[i])) {\n\t\t\treturn bin[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid addToTable(TranspositionTable* t, GameState* k) {\n\tint hv = hashGameState(k) % TABLE_SIZE;\n\tGameState** bin = t->bins[hv];\n\tfor (int i = 0; i < TABLE_BIN_SIZE; i++) {\n\t\tif (bin[i] == NULL) {\n\t\t\tbin[i] = k;\n\t\t\tretainGameState(k);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"Overflow in hash bin %d, won't store GameState\\n\", hv);\n}\n\nvoid freeTranspositionTable(TranspositionTable* t) {\n\tfor (int i = 0; i < TABLE_SIZE; i++) {\n\t\tfor (int j = 0; j < TABLE_BIN_SIZE; j++) {\n\t\t\tif (t->bins[i][j] != NULL)\n\t\t\t\tfreeGameState(t->bins[i][j]);\n\t\t}\n\t\tfree(t->bins[i]);\n\t}\n\tfree(t->bins);\n\n\tfree(t);\n}\n\ntypedef struct {\n\tGameState* gs;\n\tint player;\n\tint other_player;\n\tint turn;\n\t\n\tint alpha;\n\tint beta;\n\n\tint best_move;\n\n\tTranspositionTable* ht;\n} GameTreeNode;\n\nGameTreeNode* newGameTreeNode(GameState* gs, int player, int other, int turn, int alpha, int beta, TranspositionTable* ht) {\n\tGameTreeNode* toR = (GameTreeNode*) malloc(sizeof(GameTreeNode));\n\ttoR->gs = gs;\n\ttoR->player = player;\n\ttoR->other_player = other;\n\ttoR->turn = turn;\n\ttoR->alpha = alpha;\n\ttoR->beta = beta;\n\ttoR->best_move = -1;\n\ttoR->ht = ht;\n\treturn toR;\n}\n\nint heuristicForState(GameState* gs, int player, int other) {\n\tif (isDraw(gs))\n\t\treturn 0;\n\n\tint term_stat = getWinner(gs);\n\tif (term_stat == player)\n\t\treturn 1000;\n\n\tif (term_stat)\n\t\treturn -1000;\n\n\t\n\treturn getHeuristic(gs, player, other);\n\t\t     \n}\n\n\n// using a global instead of qsort_r because of emscripten support\n\nGameTreeNode* g_node = NULL;\n\n\nint ascComp(const void* a, const void* b) {\n\tGameTreeNode* node = g_node;\n\treturn heuristicForState(*(GameState**) a, node->player, node->other_player) -\n\t\theuristicForState(*(GameState**) b, node->player, node->other_player);\n\t\n}\n\nint desComp(const void* a, const void* b) {\n\tGameTreeNode* node = g_node;\n\treturn heuristicForState(*(GameState**) b, node->player, node->other_player) -\n\t\theuristicForState(*(GameState**) a, node->player, node->other_player);\n\t\n}\n\nint getWeight(GameTreeNode* node, int movesLeft) {\n\tint toR;\n\tif (getWinner(node->gs) || isDraw(node->gs) || movesLeft == 0)\n\t\treturn heuristicForState(node->gs, node->player, node->other_player);\n\n\tGameState** possibleMoves = (GameState**) malloc(sizeof(GameState*) * node->gs->width);\n\tint validMoves = 0;\n\tfor (int possibleMove = 0; possibleMove < node->gs->width; possibleMove++) {\n\t\tif (!canMove(node->gs, possibleMove)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpossibleMoves[validMoves] = stateForMove(node->gs, possibleMove, (node->turn ? node->player : node->other_player));\n\t\tvalidMoves++;\n\t}\n\n\t// order possibleMoves by the heuristic\n\tg_node = node;\n\tif (node->turn) {\n\t\t// qsort_r is apparently non-standard, and won't work with emscripten. So we'll need to use a global.\n\t\tqsort(possibleMoves, validMoves, sizeof(GameState*), ascComp); \n\t} else {\n\t\tqsort(possibleMoves, validMoves, sizeof(GameState*), desComp); \n\t}\n\n\tint best_weight = (node->turn ? INT_MIN : INT_MAX);\n\n\tfor (int move = 0; move < validMoves; move++) {\n\t\t// see if the game state is already in the hash table\n\t\tGameState* inTable = lookupInTable(node->ht, possibleMoves[move]);\n\t\tint child_weight;\n\t\tint child_last_move;\n\t\tif (inTable != NULL) {\n\t\t\tchild_weight = inTable->weight;\n\t\t\tchild_last_move = possibleMoves[move]->last_move;\n\n\t\t} else {\n\t\t\tGameTreeNode* child = newGameTreeNode(possibleMoves[move], node->player, node->other_player, !(node->turn),\n\t\t\t\t\t\t\t      node->alpha, node->beta, node->ht);\n\t\t\tchild_weight = getWeight(child, movesLeft - 1);\n\t\t\tchild_last_move = child->gs->last_move;\n\t\t\tfree(child);\n\t\t}\n\n\t\n\n\t\tpossibleMoves[move]->weight = child_weight;\n\t\taddToTable(node->ht, possibleMoves[move]);\n\n\t\tif (movesLeft == LOOK_AHEAD)\n\t\t\tprintf(\"Move %d has weight %d\\n\", child_last_move, child_weight);\n\n\t\t// alpha-beta pruning\n\t\tif (!node->turn) {\n\t\t\t// min node\n\t\t\tif (child_weight <= node->alpha) {\n\t\t\t\t// MAX ensures we will never go here\n\t\t\t\ttoR = child_weight;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tnode->beta = (node->beta < child_weight ? node->beta : child_weight);\n\t\t} else {\n\t\t\t// max node\n\t\t\tif (child_weight >= node->beta) {\n\t\t\t\t// MIN ensures we will never go here\n\t\t\t\ttoR = child_weight;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tnode->alpha = (node->alpha > child_weight ? node->alpha : child_weight);\n\t\t}\n\n\t\tif (!(node->turn)) {\n\t\t\t// min node\n\t\t\tif (best_weight > child_weight) {\n\t\t\t\tbest_weight = child_weight;\n\t\t\t\tnode->best_move = child_last_move;\n\t\t\t}\n\t\t} else {\n\t\t\t// max node\n\t\t\tif (best_weight < child_weight) {\n\t\t\t\tbest_weight = child_weight;\n\t\t\t\tnode->best_move = child_last_move;\n\t\t\t}\n\t\t}\n\n\t\t\n\t}\n\ttoR = best_weight;\ndone:\n\tfor (int i = 0; i < validMoves; i++) {\n\t\tfreeGameState(possibleMoves[i]);\n\t}\n\n\tfree(possibleMoves);\n\treturn toR;\n}\n\nint getBestMove(GameTreeNode* node, int movesLeft) {\n\tgetWeight(node, movesLeft);\n\treturn node->best_move;\n}\n\n\n// END OF API\n\nvoid checkWin(GameState* gs) {\n\tint win = getWinner(gs);\n\t\n\tif (win) {\n\t\tprintf(\"Game over! %d wins!\\n\", win);\n\t\tprintGameState(gs);\n\t\texit(0);\n\t}\n\n\tif (isDraw(gs)) {\n\t\tprintf(\"Game over! Draw!\\n\");\n\t\tprintGameState(gs);\n\t\texit(0);\n\t}\n\t     \n}\n\nint bestMoveForState(GameState* gs, int player, int other_player, int look_ahead) {\n\tTranspositionTable* t1 = newTable();\n\tGameTreeNode* n = newGameTreeNode(gs, player, other_player, 1, INT_MIN, INT_MAX, t1);\n\tint move = getBestMove(n, look_ahead);\n\tfree(n);\n\tfreeTranspositionTable(t1);\n\treturn move;\n}\n\n// a couple of ease-of-use functions that will run a game in global state\n\nGameState* globalState = NULL;\n\nvoid startNewGame() {\n\tprintf(\"C STARTING NEW GAME\\n\\n\\n\");\n\tglobalState = newGameState(8, 8);\n\tprintf(\"New game started!\\n\");\n}\n\nvoid playerMove(int move) {\n\tprintf(\"C PLAYER MOVE\\n\");\n\tdrop(globalState, move, 1);\n}\n\nvoid computerMove(int look_ahead) {\n\tint move = bestMoveForState(globalState, 2, 1, look_ahead);\n\tdrop(globalState, move, 2);\n}\n\nint isGameWon() {\n\treturn getWinner(globalState);\n}\n\nint isGameDraw() {\n\treturn isDraw(globalState);\n}\n\nint isEmpty(int x, int y) {\n\tprintf(\"!!!\\n\");\n\treturn at(globalState, x, y) == EMPTY;\n}\n\nint pieceAt(int x, int y) {\n\treturn at(globalState, x, y);\n}\n\n\nint main(int argc, char** argv) {\n\tstartNewGame();\n\twhile (1) {\n\t\tint move;\n\t\tprintf(\"Move? \");\n\t\tscanf(\"%d\", &move);\n\t       \n\t\tplayerMove(move);\n \n\t\tprintGameState(globalState);\n \n\t\tcheckWin(globalState);\n \n\t\tcomputerMove(LOOK_AHEAD);\n \n\t\tprintGameState(globalState);\n \n\t\tcheckWin(globalState);\n\t}\n \n\tfreeGameState(globalState);\n \n\treturn 0;\n}\n\n"]}